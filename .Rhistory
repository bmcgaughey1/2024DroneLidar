treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
# read points
las <- readLAS(paste0(folder, outputFolder, "Sample_2024-07-30_10h42_43_004.las"))
treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
system(paste(CC, CCCmd))
system(paste(CC, CCCmd))
# Build command line for Cloudcompare -------------------------------------
# output file naming is pretty wonky and presents some problems for post-
# processing.
#
# references for command line syntax
# https://www.cloudcompare.org/doc/wiki/index.php/Command_line_mode
# https://github.com/truebelief/cc-treeiso-plugin
write(paste("-O -GLOBAL_SHIFT AUTO", paste0(folder, outputFolder, outputFile), "-C_EXPORT_FMT LAS"), file = CCCommandFile)
write(paste("-TREEISO",
"-LAMBDA1 1.0",
"-K1 5",
"-DECIMATE_RESOLUTION1 0.05",
"-LAMBDA2 20",
"-K2 20",
"-MAX_GAP 2.0",
"-DECIMATE_RESOLUTION2 0.1",
"-RHO 0.5",
"-VERTICAL_OVERLAP_WEIGHT 0.5"),
file = CCCommandFile, append = TRUE)
write(paste("-SAVE_CLOUDS",
"FILE",
paste0(folder, outputFolder, "test.las")),
file = CCCommandFile, append = TRUE)
system(paste(CC, CCCmd))
paste0(folder, outputFolder, "test.las")
folder <- "H:/2024_DroneLidar/Sprawl/"
file <- "Sprawl_002.las"
outputFolder <- "Trees/"
outputFile <- "Sample.las"
groundModel <- "raster/Sprawl_1ft_DTM.dtm"
extent <- c(486030, 5125160, 486060, 5125190)
shrubHeight <- 1.5
# cloudcompare stuff
CC <- "\"C:/Program Files/CloudCompare/CloudCompare.exe\""
CCCommandFile <- paste0(folder, outputFolder, "CC_Cmd.txt")
CCCmd <- paste0(" -SILENT -COMMAND_FILE ", CCCommandFile)
# Pre-process point cloud -------------------------------------------------
# clip a small area from one of the tiles from sprawl
ClipData(paste0(folder, file),
paste0(folder, outputFolder, outputFile),
minx = extent[1],
miny = extent[2],
maxx = extent[3],
maxy = extent[4],
ground = paste0(folder, groundModel),
zmin = shrubHeight,
class = "~2",
height = TRUE
)
# Build command line for Cloudcompare -------------------------------------
# Default output file naming is pretty wonky and presents some problems for post-
# processing. Using the FILE option on the -SAVE_CLOUDS command allows you
# to specify the output file. However, CC seems to add an extra forward slash.
# this might be because it expects backslashes on windows. Regardless, the fill
# is written with the desired file name.
#
# references for command line syntax
# https://www.cloudcompare.org/doc/wiki/index.php/Command_line_mode
# https://github.com/truebelief/cc-treeiso-plugin
write(paste("-O -GLOBAL_SHIFT AUTO", paste0(folder, outputFolder, outputFile), "-C_EXPORT_FMT LAS"), file = CCCommandFile)
write(paste("-TREEISO",
"-LAMBDA1 1.0",
"-K1 5",
"-DECIMATE_RESOLUTION1 0.05",
"-LAMBDA2 20",
"-K2 20",
"-MAX_GAP 2.0",
"-DECIMATE_RESOLUTION2 0.1",
"-RHO 0.5",
"-VERTICAL_OVERLAP_WEIGHT 0.5"),
file = CCCommandFile, append = TRUE)
write(paste("-SAVE_CLOUDS",
"FILE",
paste0(folder, outputFolder, "TreeISO_output.las")),
file = CCCommandFile, append = TRUE)
system(paste(CC, CCCmd))
# Post-process segmented point cloud --------------------------------------
# read points
las <- readLAS(paste0(folder, outputFolder, "TreeISO_output.las"))
treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
plot(las, color = "final_segs")
#             "-K2 20",
#             "-MAX_GAP 2.0",
#             "-DECIMATE_RESOLUTION2 0.1",
#             "-RHO 0.5",
#             "-VERTICAL_OVERLAP_WEIGHT 0.5"),
#       file = CCCommandFile, append = TRUE)
#
# references for command line syntax
# https://www.cloudcompare.org/doc/wiki/index.php/Command_line_mode
# https://github.com/truebelief/cc-treeiso-plugin
write(paste("-O -GLOBAL_SHIFT AUTO", paste0(folder, outputFolder, outputFile), "-C_EXPORT_FMT LAS"), file = CCCommandFile)
write(paste("-TREEISO",
"-LAMBDA1 1.0",
"-K1 5",
"-DECIMATE_RESOLUTION1 0.05",
"-LAMBDA2 20",
"-K2 20",
"-MAX_GAP 4.0",
"-DECIMATE_RESOLUTION2 0.1",
"-RHO 0.5",
"-VERTICAL_OVERLAP_WEIGHT 0.5"),
file = CCCommandFile, append = TRUE)
write(paste("-SAVE_CLOUDS",
"FILE",
paste0(folder, outputFolder, "TreeISO_output.las")),
file = CCCommandFile, append = TRUE)
system(paste(CC, CCCmd))
# read points
las <- readLAS(paste0(folder, outputFolder, "TreeISO_output.las"))
treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
# Pre-process point cloud -------------------------------------------------
# clip a small area from one of the tiles from sprawl
ClipData(paste0(folder, file),
paste0(folder, outputFolder, outputFile),
minx = extent[1],
miny = extent[2],
maxx = extent[3],
maxy = extent[4],
ground = paste0(folder, groundModel),
zmin = shrubHeight,
class = "~2"
#         , height = TRUE
)
#             "-K2 20",
#             "-MAX_GAP 2.0",
#             "-DECIMATE_RESOLUTION2 0.1",
#             "-RHO 0.5",
#             "-VERTICAL_OVERLAP_WEIGHT 0.5"),
#       file = CCCommandFile, append = TRUE)
#
# references for command line syntax
# https://www.cloudcompare.org/doc/wiki/index.php/Command_line_mode
# https://github.com/truebelief/cc-treeiso-plugin
write(paste("-O -GLOBAL_SHIFT AUTO", paste0(folder, outputFolder, outputFile), "-C_EXPORT_FMT LAS"), file = CCCommandFile)
write(paste("-TREEISO",
"-LAMBDA1 1.0",
"-K1 5",
"-DECIMATE_RESOLUTION1 0.05",
"-LAMBDA2 20",
"-K2 20",
"-MAX_GAP 4.0",
"-DECIMATE_RESOLUTION2 0.1",
"-RHO 0.5",
"-VERTICAL_OVERLAP_WEIGHT 0.5"),
file = CCCommandFile, append = TRUE)
write(paste("-SAVE_CLOUDS",
"FILE",
paste0(folder, outputFolder, "TreeISO_output.las")),
file = CCCommandFile, append = TRUE)
system(paste(CC, CCCmd))
# read points
las <- readLAS(paste0(folder, outputFolder, "TreeISO_output.las"))
treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
unique(las$final_segs)
order(unique(las$final_segs))
sort.list(unique(las$final_segs))
(base::unique(las$final_segs))
order(base::unique(las$final_segs))
sort(unique(unlist(las$final_segs[, keep], use.names = FALSE)))
sort(unique(unlist(las$final_segs, use.names = FALSE)))
plot(las, color = "final_segs")
str(las@data)
# find average XY of each segment and interpolate a ground elevation
aggregate(X~final_segs, las@data, FUN=mean)
setDT(las@data)[, list(aveX=mean(X)), final_segs]
library(data.table)
setDT(las@data)[, list(aveX=mean(X)), final_segs]
# join
ave <- merge(aveX, aveY, by = final_segs)
aveX <- setDT(las@data)[, list(aveX=mean(X)), final_segs]
aveY <- setDT(las@data)[, list(aveY=mean(Y)), final_segs]
# join
ave <- merge(aveX, aveY, by = final_segs)
# join
ave <- merge.data.table(aveX, aveY, by = final_segs)
# join
ave <- merge.data.table(aveX, aveY, by = "final_segs")
View(ave)
write.table(ave, file = paste0(folder, outputFolder, "SegmentAveXY.csv"))
write.table(ave, file = paste0(folder, outputFolder, "SegmentAveXY.csv"),
row.names = FALSE,
col.names = FALSE)
write.table(ave, file = paste0(folder, outputFolder, "SegmentAveXY.txt"),
row.names = FALSE,
col.names = FALSE)
# get ground elevation
SurfaceSample(paste0(folder, groundModel),
paste0(folder, outputFolder, "SegmentAveXY.txt"),
paste0(folder, outputFolder, "SegmentAveXYZ.txt"),
id = TRUE)
library(lidR)
library(fusionwrapr)
library(terra)
# Setup -------------------------------------------------------------------
folder <- "H:/2024_DroneLidar/Sprawl/"
file <- "Sprawl_002.las"
outputFolder <- "Trees/"
outputFile <- "Sample.las"
groundModel <- "raster/Sprawl_1ft_DTM.dtm"
extent <- c(486030, 5125160, 486060, 5125190)
shrubHeight <- 1.5
# cloudcompare stuff
CC <- "\"C:/Program Files/CloudCompare/CloudCompare.exe\""
CCCommandFile <- paste0(folder, outputFolder, "CC_Cmd.txt")
CCCmd <- paste0(" -SILENT -COMMAND_FILE ", CCCommandFile)
las <- readLAS(paste0(folder, outputFolder, "TreeISO_output.las"))
treeCount <- length(unique(las$final_segs))
plot(las, color = "final_segs")
# sort to make sure we have continuous set of identifiers...we do!!
sort(unique(unlist(las$final_segs, use.names = FALSE)))
# find average XY of each segment and interpolate a ground elevation
aggregate(X~final_segs, las@data, FUN=mean)
aggregate(Y~final_segs, las@data, FUN=mean)
library(data.table)
aveX <- setDT(las@data)[, list(aveX=mean(X)), final_segs]
aveY <- setDT(las@data)[, list(aveY=mean(Y)), final_segs]
# join
ave <- merge.data.table(aveX, aveY, by = "final_segs")
write.table(ave, file = paste0(folder, outputFolder, "SegmentAveXY.txt"),
row.names = FALSE,
col.names = FALSE)
# get ground elevation
SurfaceSample(paste0(folder, groundModel),
paste0(folder, outputFolder, "SegmentAveXY.txt"),
paste0(folder, outputFolder, "SegmentAveXYZ.txt"),
id = TRUE)
# test if points in segment start close to our height threshold
minZ <- setDT(las@data)[, list(minZ=min(Z)), final_segs]
View(minZ)
las@data)[, list(minZ=min(Z)), final_segs
las@data[, list(minZ=min(Z)), final_segs]
aveX <- las@data[, list(aveX=mean(X)), final_segs]
aveY <- las@data[, list(aveY=mean(Y)), final_segs]
# join
ave <- merge.data.table(aveX, aveY, by = "final_segs")
# join
ave <- merge(aveX, aveY, by = "final_segs")
# read output
groundZ <- read.csv(paste0(folder, outputFolder, "SegmentAveXYZ.txt"), stringsAsFactors = FALSE)
View(groundZ)
View(groundZ)
minZ <- minZ[order(final_segs), ]
View(minZ)
# create a dataframe for results
status <- data.frame(ID = integer(), ExpFactor = double(), Test1 = logical())
library(data.table)
aveX <- las@data[, list(aveX=mean(X)), final_segs]
aveY <- las@data[, list(aveY=mean(Y)), final_segs]
# join and create input for SurfaceSample
ave <- merge(aveX, aveY, by = "final_segs")
write.table(ave, file = paste0(folder, outputFolder, "SegmentAveXY.txt"),
row.names = FALSE,
col.names = FALSE)
# get ground elevation
SurfaceSample(paste0(folder, groundModel),
paste0(folder, outputFolder, "SegmentAveXY.txt"),
paste0(folder, outputFolder, "SegmentAveXYZ.txt"),
id = TRUE)
# read output...sorted
groundZ <- read.csv(paste0(folder, outputFolder, "SegmentAveXYZ.txt"), stringsAsFactors = FALSE)
# test if points in segment start close to our height threshold
minZ <- las@data[, list(minZ=min(Z)), final_segs]
# sort
minZ <- minZ[order(final_segs), ]
# test
status$Test1 <- (minZ - groundZ) < (shrubHeight + 1.0)
# test
status$Test1 <- (minZ$minZ - groundZ$Value) < (shrubHeight + 1.0)
# create a dataframe for results
status <- data.frame(ID = seq(1, treeCount), ExpFactor = double(), Test1 = logical())
# create a dataframe for results
status <- data.frame(ID = seq(1, treeCount), ExpFactor = rep(0.0, treeCount), Test1 = rep(FALSE, treeCount))
# test
status$Test1 <- (minZ$minZ - groundZ$Value) < (shrubHeight + 1.0)
View(status)
sum(status$Test1)
selectList <- status$ID[status$Test1, ]
selectList <- status$ID[, status$Test1]
selectList <- status$ID[isTrue(status$Test1), ]
selectList <- status$ID[status$Test1 = TRUE, ]
selectList <- status$ID[status$Test1 == TRUE, ]
selectList <- status$ID[status$Test1]
las2 <- las[las$final_segs %in% selectList, ]
plot(las2, color = "final_segs")
# test
htThreshold <- shrubHeight + 2.5
status$Test1 <- (minZ$minZ - groundZ$Value) < htThreshold
selectList <- status$ID[status$Test1]
las2 <- las[las$final_segs %in% selectList, ]
plot(las2, color = "final_segs")
install.packages("concaveman")
library(concaveman)
library(concaveman)
i <- 13
pts <- matrix(c(las@data$X[las@data$final_segs == i, ], las@data$Y[las@data$final_segs == i, ]))
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]))
View(pts)
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), nrow = treeCount, ncol = 2)
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), ncol = 2)
View(pts)
polygons <- concaveman(pts)
plot(pts)
plot(polygons, add = TRUE)
plot(pts)
plot(polygons, add = TRUE)
plot(pts)
plot(polygons, add = TRUE)
plot(pts)
plot(polygons, add = TRUE, col = "red")
plot(polygons, add = TRUE, col = "red", type = "l")
points <- st_as_sf(las@data, coords = c("X", "Y"), remove = FALSE, crs = 26910)
library(sf)
points <- st_as_sf(las@data, coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(points)
plot(polygons, add = TRUE, col = "red", type = "l")
points <- st_as_sf(las@data[las@data$final_segs == i], coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(points)
plot(points$final_segs)
plot.sfc(points)
plot(st_geometry(points))
plot(polygons, add = TRUE, col = "red", type = "l")
bp <- st_buffer(points, 3.0, nQuadSegs = 4)
# union buffered points
clusters <- st_cast(st_union(bp), "POLYGON")
clusters <-  sf::st_as_sf(clusters)
clusters$id <- 1:nrow(clusters)
shrunkClusters <- st_buffer(clusters, -3.0, nQuadSegs = 4)
plot(st_geometry(points))
plot(shrunkClusters, add = TRUE, col = "red", type = "l")
plot(polygons, add = TRUE, col = "cyan", type = "l")
plot(st_geometry(points), add = T)
bufDist <- 1.5
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), ncol = 2)
points <- st_as_sf(las@data[las@data$final_segs == i], coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(st_geometry(points))
plot(polygons, add = TRUE, col = "cyan", type = "l")
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
# union buffered points
clusters <- st_cast(st_union(bp), "POLYGON")
clusters <-  sf::st_as_sf(clusters)
clusters$id <- 1:nrow(clusters)
shrunkClusters <- st_buffer(clusters, -bufDist, nQuadSegs = 4)
plot(st_geometry(points))
plot(shrunkClusters, add = TRUE, col = "red", type = "l")
plot(st_geometry(points), add = T)
plot(bp, add = T)
plot(bp, add = F)
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
warnings()
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
plot(bp, add = F)
plot(st_geometry(bp), add = F)
bufDist <- 0.25
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), ncol = 2)
points <- st_as_sf(las@data[las@data$final_segs == i], coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(st_geometry(points))
plot(polygons, add = TRUE, col = "cyan", type = "l")
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
plot(st_geometry(bp), add = F)
# union buffered points
clusters <- st_cast(st_union(bp), "POLYGON")
clusters <-  sf::st_as_sf(clusters)
clusters$id <- 1:nrow(clusters)
shrunkClusters <- st_buffer(clusters, -bufDist, nQuadSegs = 4)
plot(st_geometry(points))
plot(shrunkClusters, add = TRUE, col = "red", type = "l")
plot(st_geometry(points), add = T)
plot(st_geometry(bp), add = F)
bufDist <- 0.1
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), ncol = 2)
points <- st_as_sf(las@data[las@data$final_segs == i], coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(st_geometry(points))
plot(polygons, add = TRUE, col = "cyan", type = "l")
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
# union buffered points
clusters <- st_cast(st_union(bp), "POLYGON")
clusters <-  sf::st_as_sf(clusters)
clusters$id <- 1:nrow(clusters)
shrunkClusters <- st_buffer(clusters, -bufDist, nQuadSegs = 4)
plot(st_geometry(points))
plot(shrunkClusters, add = TRUE, col = "red", type = "l")
plot(st_geometry(points), add = T)
plot(st_geometry(bp), add = T)
plot(polygons, add = TRUE, col = "cyan", type = "l")
i <- 22
bufDist <- 0.1
pts <- matrix(c(las@data$X[las@data$final_segs == i], las@data$Y[las@data$final_segs == i]), ncol = 2)
points <- st_as_sf(las@data[las@data$final_segs == i], coords = c("X", "Y"), remove = FALSE, crs = 26910)
polygons <- concaveman(points)
plot(st_geometry(points))
plot(polygons, add = TRUE, col = "cyan", type = "l")
bp <- st_buffer(points, bufDist, nQuadSegs = 4)
# union buffered points
clusters <- st_cast(st_union(bp), "POLYGON")
clusters <-  sf::st_as_sf(clusters)
clusters$id <- 1:nrow(clusters)
shrunkClusters <- st_buffer(clusters, -bufDist, nQuadSegs = 4)
plot(st_geometry(points))
plot(shrunkClusters, add = TRUE, col = "red", type = "l")
plot(st_geometry(points), add = T)
plot(st_geometry(bp), add = T)
# code to test TreeISO/CloudCompare tree segmentation approach
#
# Does data prep in R, then calls TreeISO/CC to do segmentation, then post processes
# segmented point cloud
#
# TreeISO does not require normalization but does want only points associated with
# tree so we can remove points close to the ground. Remaining points from low vegetation
# will produce segments but these will be eliminated in post-processing.
#
library(lidR)
library(fusionwrapr)
library(terra)
library(data.table)
# Setup -------------------------------------------------------------------
folder <- "H:/2024_DroneLidar/Sprawl/"
file <- "Sprawl_002.las"
outputFolder <- "Trees/"
outputFile <- "Sample.las"
groundModel <- "raster/Sprawl_1ft_DTM.dtm"
extent <- c(486030, 5125160, 486060, 5125190)
shrubHeight <- 1.5
# cloudcompare stuff
CC <- "\"C:/Program Files/CloudCompare/CloudCompare.exe\""
CCCommandFile <- paste0(folder, outputFolder, "CC_Cmd.txt")
CCCmd <- paste0(" -SILENT -COMMAND_FILE ", CCCommandFile)
# Pre-process point cloud -------------------------------------------------
# clip a small area from one of the tiles from sprawl
setGlobalCommandOptions(runCmd = FALSE)
t <- ClipData(paste0(folder, file),
paste0(folder, outputFolder, outputFile),
minx = extent[1],
miny = extent[2],
maxx = extent[3],
maxy = extent[4],
ground = paste0(folder, groundModel),
zmin = shrubHeight,
class = "~2"
#         , height = TRUE
)
# Pre-process point cloud -------------------------------------------------
# clip a small area from one of the tiles from sprawl
setGlobalCommandOptions(runCmd = FALSE, saveCmd = FALSE)
t <- ClipData(paste0(folder, file),
paste0(folder, outputFolder, outputFile),
minx = extent[1],
miny = extent[2],
maxx = extent[3],
maxy = extent[4],
ground = paste0(folder, groundModel),
zmin = shrubHeight,
class = "~2"
#         , height = TRUE
)
t
# code to test TreeISO/CloudCompare tree segmentation approach
#
# Does data prep in R, then calls TreeISO/CC to do segmentation, then post processes
# segmented point cloud
#
# TreeISO does not require normalization but does want only points associated with
# tree so we can remove points close to the ground. Remaining points from low vegetation
# will produce segments but these will be eliminated in post-processing.
#
library(lidR)
library(fusionwrapr)
library(terra)
library(data.table)
# Setup -------------------------------------------------------------------
folder <- "H:/2024_DroneLidar/Sprawl/"
file <- "Sprawl_002.las"
outputFolder <- "Trees/"
outputFile <- "Sample.las"
groundModel <- "raster/Sprawl_1ft_DTM.dtm"
extent <- c(486030, 5125160, 486060, 5125190)
shrubHeight <- 1.5
# cloudcompare stuff
CC <- "\"C:/Program Files/CloudCompare/CloudCompare.exe\""
CCCommandFile <- paste0(folder, outputFolder, "CC_Cmd.txt")
CCCmd <- paste0(" -SILENT -COMMAND_FILE ", CCCommandFile)
# Pre-process point cloud -------------------------------------------------
# clip a small area from one of the tiles from sprawl
setGlobalCommandOptions(runCmd = FALSE, saveCmd = FALSE)
t <- ClipData(paste0(folder, file),
paste0(folder, outputFolder, outputFile),
minx = extent[1],
miny = extent[2],
maxx = extent[3],
maxy = extent[4],
ground = paste0(folder, groundModel),
zmin = shrubHeight,
class = "~2"
#         , height = TRUE
)
t
